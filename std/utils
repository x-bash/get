#! /usr/bin/env bash

@use str

# Not good
X_CMD_COM_RETURN=""
@ret(){
    export X_CMD_COM_RETURN="$@"
}

@res(){
    echo "$X_CMD_COM_RETURN"
}

# WCSS #8
echon(){
    printf "%s" "$*"
}

# Normally, output the progress
@log(){ echo "$*" >&2; } # fine
@fatal(){ echo "$*" >&2; exit; } # error

# Normally, output info, json or yml
@out(){ echo "$*" >&1; }


# str.trim(){
#     local var="$*"
#     # remove leading whitespace characters
#     var="${var#"${var%%[![:space:]]*}"}"
#     # remove trailing whitespace characters
#     var="${var%"${var##*[![:space:]]}"}"   
#     echo -n "$var"
# }


# str.lower(){ echo -n $1 | tr [:upper:] [:lower:]; }


# Protected folders

rmrf(){
    for i in "$@"; do
        local tgt="$(str.trim $i)"
        [ "$tgt" == "" ] && continue

        # TODO: add other patterns
        if [ "$tgt" == "/" ]; then
            yesno "WARNING: Sure of removing '$tgt': " || continue
        fi

        rm -rf $i
    done
}

# fp

# In linux, `readlink -f <filepath>`. Not works in BSD system
# https://superuser.com/questions/330199/how-get-full-path-to-target-of-link

function readlink.fullpath(){
    local TGT=${1:?"Provide name"}

    local ORI=$(pwd)
    local A=$(readlink $TGT)
    cd $(dirname $TGT)
    cd $(dirname $A)
    local RES=$(pwd)
    cd $ORI

    echo $RES/$(basename $A)
}


# rand

# TODO: padding zero in the beginning
rand.int(){
    local ST=${1:?start number}
    local EN=${2:?end number}

    local SIZE=${3:-0}

    printf "%0${SIZE}d" $(( ( RANDOM % ($EN-$ST) )  + $ST ))
}

rand.float(){
    noop
}

rand.str(){
    noop
}


# Cookbook 1.15
# like watch command
try(){ while :; do "$@"; sleep ${INTERVAL:-3}; done }
try.until.success(){ while :; do "$@" && return; sleep ${INTERVAL:-3}; done }

repeat(){
    local time=3
    for i in `seq $time`; do
        eval "$*"
    done
}

# Using X, or using curl to include method

# WCSS #80
title(){
    if [ $# -eq 0 ]; then
        echo "Usage: $0 <title to display>" >&2
    else
        echo -e "\033]0;$@\007"
    fi
}

arr.indexof(){
    local target="$1"
    shift
    local a=0
    for i in "$@"; do
        a=$((a + 1))
        if [ "$i" == "$target" ]; then
            echo $a
            return 0
        fi
    done
    echo -1
    return 1
}


# @valid.float()
# @valid.int()
valid.float(){
    [[ "$a" =~ ^[\ \t]+[0-9]+(.[0-9]+)?[\ \t]+$ ]]
    return $?
}

valid.int(){
    [[ "$a" =~ ^[\ \t]+[0-9]+[\ \t]+$ ]]
    return $?
}


# @final(){
#     local latest_code=$(trap -p return)
#     # Smart as I, using eval to avoid the real return statement being invoked when this function ends.
#     local code="eval \"trap \\\"$1
#     ${latest_code:-trap return}
#     \\\" return\"
#     "
#     # echo "$code"
#     trap "$code" return
# }

# @catch(){
#     local latest_code=$(trap -p ERR)
#     echo after latest
#     local code="$1; ${latest_code:-trap ERR}"
#     # echo CATCH-CODE "$code"
#     trap "$code" ERR
# }

@catch-final(){
    # setup catch
    local latest_err=$(trap -p ERR)
    local catch_code="
        __RET_CODE=$?
        $1
        ${latest_err:-trap ERR}
        return $__RET_CODE
    "
    # echo "$catch_code"
    trap "$catch_code" ERR

    # setup finally
    local latest_return=$(trap -p return)
    # Smart as I, using eval to avoid the real return statement being invoked when this function ends.
    local final_code="eval \"trap \\\"trap ERR
        $2
        ${latest_err:-trap ERR}
        ${latest_return:-trap return}
    \\\" return\"
    "
    # echo "$final_code"
    trap "$final_code" return
}
